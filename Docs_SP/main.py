"""
SP Documentation Agent (Offline, Free, Ollama-based)
Generates detailed, well-formatted PDF documentation for each stored procedure in a SQL Server database.
"""

import os
import re
import html
import argparse
import json
import requests
import pyodbc
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import mm
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
)
from reportlab.lib import colors
from reportlab.pdfgen import canvas
from ollama import chat


def get_onedrive_path():
    """
    Detect user's OneDrive path (works on Windows).
    Returns full path or None if not found.
    """
    possible_vars = ["OneDrive", "OneDriveCommercial", "OneDriveConsumer"]
    for var in possible_vars:
        path = os.getenv(var)
        if path and os.path.isdir(path):
            return path
    # Fallback: check user directory manually
    user_home = os.path.expanduser("~")
    guess_path = os.path.join(user_home, "OneDrive")
    return guess_path if os.path.isdir(guess_path) else None


def upload_to_onedrive(file_path, folder_path):
    """
    Uploads a local file to the user's OneDrive using Microsoft Graph API.
    Automatically creates the folder if it doesn't exist.
    Requires an access token set in the environment variable ONEDRIVE_ACCESS_TOKEN.
    """
    access_token = os.getenv("ONEDRIVE_ACCESS_TOKEN")
    if not access_token:
        print(" OneDrive access token not found. Please set ONEDRIVE_ACCESS_TOKEN in environment.")
        return

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }

    folder_check_url = f"https://graph.microsoft.com/v1.0/me/drive/root:/{folder_path}"
    check = requests.get(folder_check_url, headers=headers)
    if check.status_code == 404:
        print(f" Folder '{folder_path}' not found. Creating it...")
        create_folder_url = "https://graph.microsoft.com/v1.0/me/drive/root/children"
        payload = {
            "name": folder_path,
            "folder": {},
            "@microsoft.graph.conflictBehavior": "rename"
        }
        res = requests.post(create_folder_url, headers=headers, json=payload)
        if res.status_code not in (200, 201):
            print(f" Failed to create folder: {res.text}")

    #  Upload file
    file_name = os.path.basename(file_path)
    upload_url = f"https://graph.microsoft.com/v1.0/me/drive/root:/{folder_path}/{file_name}:/content"

    try:
        with open(file_path, "rb") as f:
            response = requests.put(upload_url, headers={"Authorization": f"Bearer {access_token}"}, data=f)
        if response.status_code in (200, 201):
            print(f" Uploaded to OneDrive: {folder_path}/{file_name}")
        else:
            print(f" OneDrive upload failed ({response.status_code}): {response.text}")
    except Exception as e:
        print(f" Upload error: {e}")

# ----------------------------------------
# Regex helpers for table and SP detection
# ----------------------------------------

TABLE_REGEX = re.compile(
    r"\b(?:FROM|INTO|JOIN|UPDATE|MERGE\s+INTO)\s+([\[\]\.\w]+)", re.IGNORECASE
)
CALL_REGEX = re.compile(
    r"\b(?:EXEC|EXECUTE|CALL)\s+([\[\]\w\.]+)", re.IGNORECASE
)


def clean_identifier(ident: str) -> str:
    return ident.replace('[', '').replace(']', '').strip()


def extract_tables(proc_text: str):
    found = set()
    for m in TABLE_REGEX.finditer(proc_text):
        name = clean_identifier(m.group(1))
        if not name.startswith('@'):
            found.add(name)
    return sorted(found)


def extract_called_sps(proc_text: str):
    found = set()
    for m in CALL_REGEX.finditer(proc_text):
        name = clean_identifier(m.group(1))
        if not name.startswith('@') and name.lower() not in ('sp_executesql',):
            found.add(name)
    return sorted(found)


# ----------------------------------------
# Count effective SQL lines (ignores comments and blanks)
# ----------------------------------------

def count_effective_sql_lines(sql_text: str) -> int:
    # Normalize line endings
    text = sql_text.replace('\r\n', '\n').replace('\r', '\n')

    # Remove report/footer artifacts
    text = re.sub(r'Page\s+\d+\s+\|.*Generated by.*', '', text, flags=re.IGNORECASE)

    # Remove block comments (/* ... */)
    text = re.sub(r'/\*.*?\*/', '', text, flags=re.DOTALL)

    count = 0
    for raw in text.split('\n'):
        line = re.sub(r'--.*', '', raw).strip()
        if not line:
            continue
        # Skip headers or CREATE metadata junk lines
        if re.match(r'^(SET\s+ANSI|GO|USE\s+|CREATE\s+DATABASE)', line, flags=re.I):
            continue
        count += 1
    return count


# Ollama explanation generator

def generate_explanation_ollama(proc_name: str, proc_text: str, model: str = "llama3:latest"):
    print(f"Generating explanation for {proc_name} using {model}...")

    prompt = f"""
    You are an expert SQL developer and documentation writer.
    Explain the logic of the following stored procedure in detail.

    Stored procedure name: {proc_name}
    Code:
    {proc_text}

    Please return:
    1. A 2-3 sentence summary of the overall purpose.
    2. Step-by-step explanation of what it does logically (as bullet points).
    3. Mention which tables are read/written and what kind of data flow occurs.
    4. Describe any parameters and expected outcomes.
    5. Mention any dependencies or called stored procedures.
    6. Identify possible performance or safety issues (e.g., missing WHERE, large table scans, etc.).
    7. End with a short conclusion: "In summary, this SP is responsible for ...".
    """

    try:
        response = chat(model=model, messages=[{"role": "user", "content": prompt}])
        return response['message']['content'].strip()
    except Exception as e:
        return f"[Error: {e}] Could not generate explanation."


# Page number footer + branding

def add_page_number(canvas_obj, doc):
    page_num = canvas_obj.getPageNumber()
    footer_text = f"Page {page_num} | Generated by SP Documentation Agent (Offline Ollama)"
    canvas_obj.setFont("Helvetica", 8)
    canvas_obj.setFillColor(colors.grey)
    canvas_obj.drawRightString(200 * mm, 10 * mm, footer_text)


# SQL Syntax Highlighting Helper (robust)

SQL_KEYWORDS = [
    "CREATE", "ALTER", "DROP", "TRUNCATE",
    "SELECT", "INSERT", "UPDATE", "DELETE", "MERGE",
    "BEGIN", "COMMIT", "ROLLBACK", "SAVEPOINT",
    "FROM", "WHERE", "GROUP", "BY", "ORDER", "HAVING", "INTO",
    "VALUES", "SET", "AS", "DISTINCT", "TOP",
    "JOIN", "INNER", "LEFT", "RIGHT", "FULL", "OUTER", "ON",
    "CASE", "WHEN", "THEN", "ELSE", "END",
    "ISNULL", "COALESCE", "NULL", "NOT", "AND", "OR", "IN", "BETWEEN", "LIKE", "EXISTS",
    "DECLARE", "EXEC", "EXECUTE", "PROCEDURE", "FUNCTION", "RETURNS", "TABLE",
    "IF", "WHILE", "PRINT", "RETURN", "GO", "USE", "WITH", "UNION", "ALL",
    "COUNT", "SUM", "AVG", "MIN", "MAX"
]

keyword_pattern = re.compile(
    r"\b(" + "|".join(re.escape(k) for k in SQL_KEYWORDS) + r")\b",
    flags=re.IGNORECASE
)


def highlight_sql_line(line: str) -> str:
    """
    Preserve indentation, escape HTML and apply safe keyword/element highlighting.
    Returns a single HTML-safe string suitable for ReportLab Paragraph.
    """
    m = re.match(r"^(\s*)", line)
    leading = m.group(1) if m else ""
    nbsp_leading = "&nbsp;" * len(leading)

    # Separate inline comment (--)
    comment_part = ""
    code_part = line
    idx = line.find('--')
    if idx != -1:
        code_part = line[:idx]
        comment_part = line[idx:]

    esc_code = html.escape(code_part)
    esc_comment = html.escape(comment_part) if comment_part else ""

    # Highlight strings (single quotes)
    esc_code = re.sub(
        r"&#x27;(.*?)&#x27;", r'<font color="green">\'\1\'</font>', esc_code, flags=re.DOTALL
    )

    # Highlight bracketed identifiers [name]
    esc_code = re.sub(r"(\[[^\]]+\])", r'<font color="teal">\1</font>', esc_code)

    # Highlight parameters @param
    esc_code = re.sub(r"(@[A-Za-z0-9_]+)", r'<font color="darkorange">\1</font>', esc_code)

    # Highlight keywords
    def _kw_repl(m):
        kw = m.group(1).upper()
        return f'<font color="blue"><b>{kw}</b></font>'

    esc_code = keyword_pattern.sub(_kw_repl, esc_code)

    if esc_comment:
        esc_comment = f'<font color="purple">{esc_comment}</font>'

    return f"{nbsp_leading}{esc_code}{esc_comment}"


# Markdown formatting conversion

def markdown_to_html_bold(text: str) -> str:
    """Convert Markdown-style **bold** or *italic* to HTML for ReportLab rendering."""
    text = re.sub(r"\*\*(.*?)\*\*", r"<b>\1</b>", text)  # bold
    text = re.sub(r"\*(.*?)\*", r"<i>\1</i>", text)      # italic
    return text


# PDF Generator

def make_pdf(output_path, metadata):
    doc = SimpleDocTemplate(
        output_path,
        pagesize=A4,
        rightMargin=20 * mm,
        leftMargin=20 * mm,
        topMargin=15 * mm,
        bottomMargin=15 * mm
    )

    styles = getSampleStyleSheet()
    styles.add(ParagraphStyle(name="TitleCustom", fontSize=18, leading=22, spaceAfter=12, alignment=1))
    styles.add(ParagraphStyle(name="Heading1Custom", fontSize=16, leading=20, spaceAfter=10, textColor=colors.darkblue))
    styles.add(ParagraphStyle(name="Heading2Custom", fontSize=14, leading=18, spaceAfter=8, textColor=colors.darkslateblue))
    styles.add(ParagraphStyle(name="BodyTextCustom", fontSize=11, leading=14, spaceAfter=6))
    styles.add(ParagraphStyle(name="BulletCustom", fontSize=11, leading=14, leftIndent=18, spaceAfter=4))
    styles.add(ParagraphStyle(
        name="SQLLine", fontName="Courier", fontSize=8.5, leading=10.5,
        backColor=colors.whitesmoke, leftIndent=0, rightIndent=0,
        borderPadding=4, borderColor=colors.lightgrey, borderWidth=0.5,
        spaceBefore=0, spaceAfter=0
    ))

    story = []

    # Elegant PDF Title Header

    title_text = """
    <b><font size=18 color="darkblue">Stored Procedure Documentation Report</font></b><br/>
    """
    subtitle_text = f"""
    <font size=11 color="darkslategray">
    Database: <b>{metadata['database']}</b> &nbsp;&nbsp;|&nbsp;&nbsp;
    Schema: <b>{metadata['schema']}</b> &nbsp;&nbsp;|&nbsp;&nbsp;
    Procedure: <b>{metadata['name']}</b>
    </font>
    """

    story.append(Paragraph(title_text, styles['BodyTextCustom']))
    story.append(Paragraph(subtitle_text, styles['BodyTextCustom']))
    story.append(Spacer(1, 14))
    story.append(Paragraph('<font color="lightgrey">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</font>', styles['BodyTextCustom']))
    story.append(Spacer(1, 12))

    # Info Table
    meta_table_data = [
        ['Database', metadata['database']],
        ['Schema', metadata['schema']],
        ['Lines of Code', str(metadata['lines'])],
        ['Priority', metadata['priority']],
    ]

    t = Table(meta_table_data, colWidths=[60 * mm, 100 * mm])
    t.setStyle(TableStyle([
        ('BOX', (0, 0), (-1, -1), 0.5, colors.darkblue),
        ('INNERGRID', (0, 0), (-1, -1), 0.25, colors.lightblue),
        ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.whitesmoke, colors.lightcyan]),
        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
    ]))
    story.append(t)
    story.append(Spacer(1, 15))

    # Tables and SPs
    story.append(Paragraph('<b>Tables Referenced:</b> ' + (', '.join(metadata['tables']) or 'None'), styles['BodyTextCustom']))
    story.append(Spacer(1, 6))
    story.append(Paragraph('<b>Stored Procedures Called:</b> ' + (', '.join(metadata['called_sps']) or 'None'), styles['BodyTextCustom']))
    story.append(Spacer(1, 10))

    # Explanation Section
    story.append(Paragraph('<b>Explanation</b>', styles['Heading1Custom']))
    story.append(Spacer(1, 6))

    for para in str(metadata.get('explanation', '')).splitlines():
        para = para.strip()
        if not para:
            story.append(Spacer(1, 3))
            continue
        para = markdown_to_html_bold(para)
        if para.startswith(('- ', 'â€¢ ')):
            para = para[2:].strip()
            story.append(Paragraph(f'â€¢ {para}', styles['BulletCustom']))
        else:
            story.append(Paragraph(para, styles['BodyTextCustom']))
        story.append(Spacer(1, 3))

    story.append(Spacer(1, 10))

    # Code Section
    story.append(Paragraph('<b>Stored Procedure Code</b>', styles['Heading2Custom']))
    story.append(Spacer(1, 6))

    sql_code = metadata.get('code', '') or ''
    sql_line_style = ParagraphStyle(
        name="SQLLineClean",
        fontName="Courier",
        fontSize=8.5,
        leading=11,
        textColor=colors.black,
        leftIndent=8,
        spaceBefore=0,
        spaceAfter=0,
        backColor=None
    )

    for raw_line in sql_code.splitlines():
        if not raw_line.strip():
            story.append(Spacer(1, 3))
            continue
        highlighted = highlight_sql_line(raw_line)
        story.append(Paragraph(highlighted, sql_line_style))
        story.append(Spacer(1, 0.5))

    story.append(Spacer(1, 12))
    doc.build(story, onLaterPages=add_page_number, onFirstPage=add_page_number)


# SQL Server connection + main logic

def get_connection(server, database, user=None, password=None, trusted=False):
    if trusted:
        conn_str = f"DRIVER={{ODBC Driver 17 for SQL Server}};SERVER={server};DATABASE={database};Trusted_Connection=yes;"
    else:
        conn_str = f"DRIVER={{ODBC Driver 17 for SQL Server}};SERVER={server};DATABASE={database};UID={user};PWD={password};"
    return pyodbc.connect(conn_str)


def process_all_procs(conn, database, output_dir, model="llama3:latest", onedrive=False, onedrive_folder=None):
    cursor = conn.cursor()
    sql = """
    SELECT
        SCHEMA_NAME(p.schema_id) as schema_name,
        p.name as proc_name,
        m.definition
    FROM sys.procedures p
    JOIN sys.sql_modules m ON p.object_id = m.object_id
    WHERE m.definition IS NOT NULL
    ORDER BY p.name
    """
    cursor.execute(sql)
    rows = cursor.fetchall()
    print(f"ðŸ“¦ Found {len(rows)} stored procedures.")

    os.makedirs(output_dir, exist_ok=True)

    for idx, (schema_name, proc_name, definition) in enumerate(rows, start=1):
        display_name = f"{schema_name}.{proc_name}"
        print(f"\n[{idx}/{len(rows)}] Documenting: {display_name}")
        pdf_path = os.path.join(output_dir, f"{schema_name}.{proc_name}.pdf")
        if os.path.exists(pdf_path):
            print(f"Skipping {display_name} (PDF already exists)")
            continue
        lines = count_effective_sql_lines(definition)

        if lines >= 500:
            priority = "High"
        elif 250 <= lines < 500:
            priority = "Medium"
        else:
            priority = "Low"

        tables = extract_tables(definition)
        called_sps = extract_called_sps(definition)
        explanation = generate_explanation_ollama(proc_name, definition, model)

        metadata = {
            'database': database,
            'schema': schema_name,
            'name': proc_name,
            'lines': lines,
            'priority': priority,
            'tables': tables,
            'called_sps': called_sps,
            'explanation': explanation,
            'code': definition,
        }


        make_pdf(pdf_path, metadata)
        if onedrive:
            upload_to_onedrive(pdf_path, onedrive_folder)
            print(f" Uploaded to OneDrive folder: {onedrive_folder}")
        else:
            print(f" Saved locally: {pdf_path}")

# CLI

def main():
    parser = argparse.ArgumentParser(description="Generate SP documentation using Ollama (offline, formatted PDFs)")
    parser.add_argument('--server', required=True)
    parser.add_argument('--database', required=True)
    parser.add_argument('--user', default=None)
    parser.add_argument('--password', default=None)
    parser.add_argument('--trusted', action='store_true')
    parser.add_argument('--output', default='./sp_docs')
    parser.add_argument("--onedrive", action="store_true", help="Upload generated PDFs to OneDrive")
    parser.add_argument("--onedrive-folder", default="SP_Docs", help="OneDrive folder name to upload to")
    parser.add_argument('--model', default='llama3:latest', help='Ollama model name (default: llama3:latest)')
    args = parser.parse_args()

    onedrive_path = get_onedrive_path()
    if not onedrive_path:
        print("OneDrive folder not found. Using local ./sp_docs instead.")
        output_dir = os.path.join(os.getcwd(), "sp_docs")
    else:
        output_dir = os.path.join(onedrive_path, "SP_Docs")

    conn = get_connection(args.server, args.database, args.user, args.password, args.trusted)
    try:
        process_all_procs(conn, args.database, output_dir, args.model, args.onedrive, args.onedrive_folder)
    finally:
        conn.close()


if __name__ == '__main__':
    main()

